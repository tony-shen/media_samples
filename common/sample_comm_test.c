/*
 * Copyright 2021 Rockchip Electronics Co. LTD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
#ifdef __cplusplus
#if __cplusplus
extern "C" {
#endif
#endif /* End of #ifdef __cplusplus */

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <time.h>
#include <unistd.h>

#include "sample_comm.h"

#define BUFFER_BYTE_SIZE 255

void SAMPLE_COMM_TEST_CreateFile(RK_CHAR *path, FILE **fp, RK_CHAR *mod, RK_S32 chnid,
                                 RK_S32 file_index) {
	RK_CHAR name[BUFFER_BYTE_SIZE] = {0};
	*fp = RK_NULL;
	snprintf(name, sizeof(name), "/%s/%s_chn%d_%d.bin", path, mod, chnid, file_index);
	*fp = fopen(name, "wb");
	RK_LOGD("*fp:%p  chnid %d path:%s", *fp, chnid, name);
	if (*fp == RK_NULL) {
		RK_LOGE("can't open %s file !\n", name);
	}
}

RK_U64 SAMPLE_COMM_TEST_GetNowUs(void) {
	struct timespec time = {0, 0};
	clock_gettime(CLOCK_MONOTONIC, &time);
	return (RK_U64)time.tv_sec * 1000000 + (RK_U64)time.tv_nsec / 1000;
}

RK_S32 SAMPLE_COMM_TEST_ReadFrameFromFile(SAMPLE_READ_FRAME_CTX_S *pReadFrame) {
	RK_S32 fread_return_size = 0;
	PIC_BUF_ATTR_S stBufAttr;
	MB_PIC_CAL_S stCalResult;
	FILE *fp = RK_NULL;

	RK_LOGE("path = %s", pReadFrame->pFilePath);

	fp = fopen(pReadFrame->pFilePath, "rb");
	if (!fp) {
		RK_LOGE("fopen file failure, please check file path,  automatically generated by "
		        "the CPU");
	}

	memset(&stBufAttr, 0, sizeof(PIC_BUF_ATTR_S));
	memset(&stCalResult, 0, sizeof(MB_PIC_CAL_S));

	stBufAttr.u32Width = pReadFrame->s32FrameWidth;
	stBufAttr.u32Height = pReadFrame->s32FrameHeight;
	stBufAttr.enCompMode = pReadFrame->enCompMode;
	stBufAttr.enPixelFormat = pReadFrame->enPixelFormat;

	RK_MPI_CAL_COMM_GetPicBufferSize(&stBufAttr, &stCalResult);

	RK_MPI_SYS_MmzAlloc_Cached(&(pReadFrame->pipe_frames->stVFrame.pMbBlk), RK_NULL,
	                           RK_NULL, stCalResult.u32MBSize);
	pReadFrame->pipe_frames->stVFrame.u32Width = pReadFrame->s32FrameWidth;
	pReadFrame->pipe_frames->stVFrame.u32Height = pReadFrame->s32FrameHeight;
	pReadFrame->pipe_frames->stVFrame.u32VirWidth = stCalResult.u32VirWidth;
	pReadFrame->pipe_frames->stVFrame.u32VirHeight = stCalResult.u32VirHeight;
	pReadFrame->pipe_frames->stVFrame.enCompressMode = pReadFrame->enCompMode;
	pReadFrame->pipe_frames->stVFrame.enPixelFormat = pReadFrame->enPixelFormat;

	if (fp) {
		fread_return_size =
		    fread(RK_MPI_MB_Handle2VirAddr(pReadFrame->pipe_frames->stVFrame.pMbBlk), 1,
		          stCalResult.u32MBSize, fp);
		if (fread_return_size != stCalResult.u32MBSize) {
			RK_LOGE("fread %s failure!!!", pReadFrame->pFilePath);
			RK_MPI_MB_ReleaseMB(pReadFrame->pipe_frames->stVFrame.pMbBlk);
			return RK_FAILURE;
		}
	} else {
		static int frame_count = 0;
		RK_LOGE("read yuv from cpu");
		SAMPLE_COMM_FillImage(
		    RK_MPI_MB_Handle2VirAddr(pReadFrame->pipe_frames->stVFrame.pMbBlk),
		    pReadFrame->s32FrameWidth, pReadFrame->s32FrameHeight,
		    stCalResult.u32VirWidth, stCalResult.u32VirHeight, pReadFrame->enPixelFormat,
		    frame_count++);
	}
	RK_MPI_SYS_MmzFlushCache(pReadFrame->pipe_frames->stVFrame.pMbBlk, RK_FALSE);
	if (fp) {
		fclose(fp);
		fp = RK_NULL;
	}

	return RK_SUCCESS;
}

#ifdef __cplusplus
#if __cplusplus
}
#endif
#endif /* End of #ifdef __cplusplus */
